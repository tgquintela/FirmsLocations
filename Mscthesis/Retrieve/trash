



class Neighbourhood():
    """
    Retrieve neighs.
    """
    aggretriever = None
    retriever = None
    aggfeatures = None

    def define_aggretriever(self, aggregator, df, reindices):
        "Define the aggregation and its retriever."
        ##### TODO: Reindices, grid_application
        loc_vars = aggregator.typevars['loc_vars']
        df[loc_vars] = self.aux_def_aggretriever(aggregator, df)
        agglocs, self.aggfeatures = aggregator.retrieve_aggregation(df,
                                                                    reindices)
        agglocs = np.array(agglocs)
        ndim, N_t = len(agglocs.shape), agglocs.shape[0]
        agglocs = agglocs if ndim > 1 else agglocs.reshape((N_t, 1))
        self.define_aggretriever_spec(agglocs)

    def define_mainretriever(self, df, loc_vars):
        "Define the main retriever."
        locs = df[loc_vars].as_matrix().astype(float)
        ndim, N_t = len(locs.shape), df.shape[0]
        locs = locs if ndim > 1 else locs.reshape((N_t, 1))
        self.retriever = self.define_mainretriever_spec(locs)
        #self.retriever = KDTree(locs, leafsize=10000)

    def retrieve_neigh(self, point_i, cond_i, info_i):
        """Retrieve the neighs information and the type of retrieving.
        Type of retrieving:
        - aggfeatures: aggregate
        - indices of neighs: neighs_i
        """
        typereturn = self.get_type_return(point_i, cond_i)
        if typereturn:
            neighbourhood = self.retrieve_neighs_agg(point_i, info_i)
        else:
            neighbourhood = self.retrieve_neighs(point_i, info_i)
        return neighbourhood, typereturn

    ###########################################################################
    ########################## Condition aggregation ##########################
    ###########################################################################
    def set_aggcondition(self, f):
        "Setting condition function for aggregate data retrieval."
        self.cond_funct = f

    def get_type_return(self, point_i, cond_i):
        "Apply condition setted."
        ## TODO: Add the possibility to not be in aggregate and return False
        return self.cond_funct(point_i, cond_i)


class GridNeigh(Neighbourhood):
    """Neighbourhood grid-based object. It is an static retriever. This means
    that all the computations queries can be retrieved the aggregate values.
    """

    def __init__(self, locs, grid_size, xlim=(None, None), ylim=(None, None)):
        "Main function to map a group of points in a 2d to a grid."
        ## TODO: locs not needed.
        self.create_grid(locs, grid_size, xlim, ylim)

    ##################### Definition of particularities ######################
    ##########################################################################
    def create_grid(self, locs, grid_size, xlim=(None, None),
                    ylim=(None, None)):
        self.x, self.y = create_grid(locs, grid_size, xlim, ylim)

    def apply_grid(self, locs):
        locs_grid = apply_grid(locs, self.x, self.y)
        return locs_grid

    ####################### Definition of aggretriever #######################
    ##########################################################################
    def aux_def_aggretriever(self, aggregator, df):
        locs = df[aggregator.typevars['loc_vars']].as_matrix()
        return self.apply_grid(locs)

    def define_aggretriever_spec(self, agglocs):
        "Particular definition of aggretriever."
        self.aggretriever = agglocs

    ######################## Definition of retriever #########################
    ##########################################################################
    def define_mainretriever_spec(self, locs):
        "Particular definition of retriever."
        self.retriever = None

    ################################ Retrieve ################################
    ##########################################################################
    def retrieve_neighs_agg(self, point_i, info_i):
        point_i = point_i.reshape(1, point_i.shape[0])
        point_i = apply_grid(point_i, self.x, self.y)
        ndim = self.aggretriever.shape[1]
        logi = np.ones(self.aggretriever.shape[0])
        for i in ndim:
            logi = np.logical_and(logi, self.aggretriever == point_i)
        return logi, 'aggregate'

    def retrieve_neighs(self, point_i, info_i):
        return self.retrieve_neighs_agg(point_i)


class IrregularNeigh(Neighbourhood):
    """Neighbourhood grid-based object. It is an static retriever. This means
    that all the computations queries can be retrieved the aggregate values.
    """

    def __init__(self, interpolation_pars=None):
        ## TODO: locs not needed.
        self.interpolation_pars = interpolation_pars

    ##################### Definition of particularities ######################
    ##########################################################################
    def fit_regions(self, locs, neighs_assignation):
        # Function of locs, neighs_assignation and interpolation_pars
        self.borders = border_creation(locs, neighs_assignation,
                                       self.interpolation_pars)

    def apply_regions(self, locs):
        locs_region = apply_regions(locs, self.regions)
        return locs_region

    ####################### Definition of aggretriever #######################
    ##########################################################################
    def aux_def_aggretriever(self, aggregator, df):
        locs = df[aggregator.typevars['loc_vars']].as_matrix()
        return self.apply_regions(locs)

    def define_aggretriever_spec(self, agglocs):
        "Particular definition of aggretriever."
        self.aggretriever = agglocs

    ######################## Definition of retriever #########################
    ##########################################################################
    def define_mainretriever_spec(self, locs):
        "Particular definition of retriever."
        self.retriever = None

    ################################ Retrieve ################################
    ##########################################################################
    def retrieve_neighs_agg(self, point_i, info_i):
        point_i = point_i.reshape(1, point_i.shape[0])
        point_i = apply_grid(point_i, self.x, self.y)
        ndim = self.aggretriever.shape[1]
        logi = np.ones(self.aggretriever.shape[0])
        for i in ndim:
            logi = np.logical_and(logi, self.aggretriever == point_i)
        return logi, 'aggregate'

    def retrieve_neighs(self, point_i, info_i):
        return self.retrieve_neighs_agg(point_i)


class CircularNeigh(Neighbourhood):
    """General Neighbourhood for circular considerations. It could have
    variable radius.
    """
    def __init__(self):
        pass

    ####################### Definition of aggretriever #######################
    ##########################################################################
    def aux_def_aggretriever(self, aggregator, df):
        locs = df[aggregator.typevars['loc_vars']].as_matrix()
        return locs

    def define_aggretriever_spec(self, agglocs):
        "Particular definition of aggretriever."
        self.aggretriever = KDTree(agglocs, leafsize=100)

    ######################## Definition of retriever #########################
    ##########################################################################
    def define_mainretriever_spec(self, locs):
        "Particular definition of retriever."
        self.retriever = KDTree(locs, leafsize=locs.shape[0]/100)

    ################################ Retrieve ################################
    ##########################################################################
    def retrieve_neighs_agg(self, point_i, info_i):
        neighs = self.aggretriever.query_ball_point(point_i, info_i)
        return neighs, 'aggregate'

    def retrieve_neighs(self, point_i, info_i):
        neighs = self.retriever.query_ball_point(point_i, info_i)
        return neighs, 'individual'


class KNeigh(Neighbourhood):
    "General neighbourhood composed by a fixed number of neighbours."

    def __init__(self, k):
        self.k = k

    ####################### Definition of aggretriever #######################
    ##########################################################################
    def aux_def_aggretriever(self, aggregator, df):
        locs = df[aggregator.typevars['loc_vars']].as_matrix()
        return locs

    def define_aggretriever_spec(self, agglocs):
        "Particular definition of aggretriever."
        self.aggretriever = KDTree(agglocs, leafsize=100)

    ######################## Definition of retriever #########################
    ##########################################################################
    def define_mainretriever_spec(self, locs):
        "Particular definition of retriever."
        self.retriever = KDTree(locs, leafsize=locs.shape[0]/100)

    ################################ Retrieve ################################
    ##########################################################################
    def retrieve_neighs_agg(self, point_i, info_i):
        neighs = self.aggretriever.query(point_i, info_i)[1]
        return neighs, 'aggregate'

    def retrieve_neighs(self, point_i, info_i):
        neighs = self.retriever.query(point_i, info_i)[1]
        return neighs, 'individual'


###############################################################################
############################# Circular functions ##############################
###############################################################################
def define_aggretriever_circ(aggregator, locs_grid, type_arr, reindices):
    "Define the aggretriever information."
    # locs_grid, reindices, type_arr
    agglocs, aggfeatures = aggregator.retrieve_aggregation(locs_grid, None,
                                                           type_arr, reindices)
    aggretriever = KDTree(agglocs, leafsize=100)
    return aggretriever, aggfeatures


def aggretrieve_grid(point_i, agglocs, aggfeatures):
    neighs = retrieve_aggneighs(point_i, agglocs)
    feats = aggretrieve_vals(neighs, aggfeatures)
    return feats


def retrieve_aggneighs(point_i, agglocs):
    "Retrieve aggregate neighs."
    aggneighs = agglocs.query_ball_point(point_i, self.r)
    return aggneighs


def aggretrieve_vals(neighs, aggfeatures):
    # agglocs are unique locations
    if logi.sum() == 0:
        feats = np.zeros(aggfeatures.shape[1])
    else:
        feats = aggfeatures[logi, :]
    return feats





    def define_mainretriever(self, locs):
        "Define the main retriever."
        ndim = len(locs.shape)
        locs = locs if ndim > 1 else locs.reshape((N_t, 1))
        self.retriever = KDTree(locs, leafsize=10000)

    def define_aggretriever(self, aggregator, df, reindices):
        "Define the aggregation and its retriever."
        ##### TODO: Reindices
        self.aggfeatures, agglocs = aggregator.retrieve_aggregation(df)
        agglocs = np.array(agglocs)
        ndim, N_t = len(agglocs.shape), agglocs.shape[0]
        agglocs = agglocs if ndim > 1 else agglocs.reshape((N_t, 1))
        self.aggretriever = KDTree(agglocs, leafsize=100)

    def create_aggretriever(self, locs):
        "Creation of the aggretriever."

        agg_desc = None
        if self.bool_agg:
            agg_var = self.var_types['agg_var']
            ## TODO: Compute tables
            agg_desc, axis, locs2 = compute_aggregate_counts(df, agg_var,
                                                             loc_vars,
                                                             type_vars,
                                                             reindices)
            kdtree2 = KDTree(locs2, leafsize=100)

        # type_arr
        type_arr = df[type_vars].as_matrix().astype(int)
        ndim = len(type_arr.shape)
        type_arr = type_arr if ndim == 2 else type_arr.reshape((N_t, 1))
        # clean unnecessary
        del df



###############################################################################
############################### Grid functions ################################
###############################################################################
def aggretrieve_grid(point_i, agglocs, aggfeatures):
    neighs = retrieve_aggneighs(point_i, agglocs)
    feats = aggretrieve_vals(neighs, aggfeatures)
    return feats


def retrieve_aggneighs(point_i, agglocs):
    "Retrieve aggregate neighs."
    logi = agglocs == point_i
    return logi


def aggretrieve_vals(neighs, aggfeatures):
    # agglocs are unique locations
    if logi.sum() == 0:
        feats = np.zeros(aggfeatures.shape[1])
    else:
        feats = aggfeatures[logi, :]
    return feats
